# Explain Code Command

## Purpose

The `explain-code` command provides comprehensive, AI-powered explanations of code segments, functions, classes, or entire files. It combines natural language explanations with visual diagrams to help developers understand complex code quickly and thoroughly.

## Command Syntax

```bash
/explain-code [target]
```

## Parameters

### Target (Required)

- `[function-name]` - Specific function to explain
- `[class-name]` - Entire class explanation
- `[file-path]` - Explain entire file
- `[line-range]` - Explain specific lines (e.g., "125-150")
- `current-selection` - Explain currently selected code in IDE

The command automatically:

- Includes visual diagrams (flowcharts, sequence diagrams, class diagrams)
- Uses intermediate complexity level (technical but accessible)
- Provides full context (includes dependencies and related components)
- Saves explanations to `.writ/explanations/` for future reference

## Examples

```bash
# Explain a specific function
/explain-code calculateUserDiscount

# Explain a class
/explain-code PaymentProcessor

# Explain entire file
/explain-code src/auth/AuthService.js

# Explain specific line range
/explain-code "src/utils/helpers.js:45-78"

# Explain currently selected code in IDE
/explain-code current-selection
```

## Output Structure

All explanations are displayed in chat and automatically saved to `.writ/explanations/`

### Chat Display

```
ğŸ“‹ Function Overview
â”œâ”€â”€ Purpose: What this code does
â”œâ”€â”€ Parameters: Input expectations
â”œâ”€â”€ Return Value: What it outputs
â”œâ”€â”€ Key Logic: Step-by-step breakdown
â””â”€â”€ Usage Examples: How to call it

ğŸ”„ Execution Flow
â”œâ”€â”€ [Flowchart diagram showing decision paths]
â”œâ”€â”€ Decision points and branches
â”œâ”€â”€ Error handling paths
â””â”€â”€ Performance characteristics

ğŸ—ï¸ Architecture Context
â”œâ”€â”€ Where this fits in the system
â”œâ”€â”€ Dependencies and related components
â”œâ”€â”€ Design patterns used
â””â”€â”€ Integration points

âš¡ Technical Details
â”œâ”€â”€ Time complexity
â”œâ”€â”€ Memory usage
â”œâ”€â”€ Potential issues
â””â”€â”€ Optimization opportunities
```

### Saved Format

````markdown
# Code Explanation: [Target Name]

_Generated on [DATE]_

## Overview

[Natural language summary]

## Execution Flow

```mermaid
[Generated diagram]
```
````

## Detailed Breakdown

[Step-by-step explanation]

## Architecture Context

[How it fits in the system]

## Usage Examples

[Code examples]

## Related Components

[Links to other explanations]

---

_Generated by Writ on [timestamp]_
_Last updated: [timestamp]_

```

## File Organization

Saved explanations are stored with date prefixes for chronological organization:

```

.writ/
â””â”€â”€ explanations/
â”œâ”€â”€ 2024-01-15-AuthenticationFlow.md
â”œâ”€â”€ 2024-01-16-PaymentProcessor.md
â”œâ”€â”€ 2024-01-16-UserService.md
â””â”€â”€ 2024-01-17-SearchAlgorithm.md

````

Files are named using the format: `[DATE]-[target-name].md` where DATE is YYYY-MM-DD format.

## Auto-Save Behavior

All explanations are automatically saved to `.writ/explanations/` using the format `[DATE]-[target-name].md`.

Get current date by running: `npx @devobsessed/writ date`

**Example filename:** `.writ/explanations/2025-09-27-AuthenticationFlow.md`

## Integration Points

### With Other Commands
```bash
# Saved explanations can be referenced by other commands
/research authentication
/create-spec payment-processing
/execute-task "optimize the user search"

# AI can access saved explanations from .writ/explanations/
# to provide better context for other commands
```

### With IDE Integration

- Hover over function calls to see saved explanations
- Right-click context menu: "Explain with Writ"
- Inline explanation widgets for complex code blocks

## Management Commands

```bash
# List all saved explanations
/list-explanations

# Search explanations
/search-explanations "authentication"

# Show explanation history
/explanation-history calculateDiscount

# Update outdated explanations when code changes
/refresh-explanations --check-code-changes
```

## Diagram Types Generated

### Flowcharts

- Control flow through functions
- Decision trees for complex logic
- Error handling paths

### Sequence Diagrams

- Function call sequences
- API interaction flows
- Database transaction flows

### Class Diagrams

- Object relationships
- Inheritance hierarchies
- Dependency structures

### Architecture Diagrams

- Component interactions
- Data flow through system
- Service communication patterns

## Output Characteristics

All explanations use a consistent intermediate technical level that balances accessibility with depth:

- **Technical but accessible**: Explains how the code works with some optimization details
- **Full context**: Always includes related functions, dependencies, and architectural context
- **Visual diagrams**: Every explanation includes appropriate flowcharts, sequence diagrams, or class diagrams
- **Comprehensive coverage**: Shows how the code fits in the entire system

## AI Processing Workflow

1. **Code Analysis**: Parse syntax, identify patterns, measure complexity
2. **Context Gathering**: Understand surrounding code and dependencies
3. **Explanation Generation**: Create intermediate-level natural language description
4. **Diagram Creation**: Generate appropriate visual representations (flowcharts, sequence, class diagrams)
5. **Formatting**: Structure output for both chat display and markdown file
6. **Auto-Save**: Save explanation to `.writ/explanations/` with date-prefixed filename `[DATE]-[target-name].md`

## Error Handling

### Common Issues

- **Code not found**: "Could not locate [target]. Please check the path/name."
- **Too complex**: "This code is very complex. Consider breaking into smaller explanations."
- **Limited context**: "Some context may be missing. Ensure related files are accessible."

### Fallback Behaviors

- If diagrams fail to generate, provide text-based flow description
- If target is ambiguous, offer multiple options to choose from
- If code is too large, suggest breaking into smaller segments

## Success Metrics

Track effectiveness through:

- Explanation clarity ratings from users
- Frequency of re-explanations for same code
- Time saved in code reviews and onboarding
- Reduction in "what does this do?" questions during development

## Future Enhancements

### Planned Features

- Interactive explanations with expandable sections
- Voice-generated explanations for accessibility
- Integration with code review tools
- Automatic explanation updates when code changes
- Explanation versioning and history tracking

### Advanced Capabilities

- Performance profiling integration
- Security vulnerability highlighting in explanations
- Code quality suggestions as part of explanations
- Integration with documentation generation tools

```

```
````
